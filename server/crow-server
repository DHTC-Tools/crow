#!/usr/bin/env python

# curl -H 'Content-Type: application/json' -d @d.json "http://db.mwt2.org:8080/" 
# curl -H 'Content-Type: application/json' -d @d.json "http://db.mwt2.org:8080/trace"
# cat d.json 
# { "method" : "guru.test", "params" : [ "Guru" ], "id" : 123 }
# curl -H "Accept: application/json" -X post "http://db.mwt2.org:8080/ips"
# curl	-H "Accept: application/json" -X post "http://db.mwt2.org:8080/network?source=MWT2&destination=AGLT2"

# curl	-H "Accept: application/json" -X post "http://db.mwt2.org:8080/distincts?hours=123

# curl	-H "Accept: application/json" -H "Content-Type: application/json" -d @d.json "http://db.mwt2.org:8080/general"

import os
import sys
import random
import hashlib
import urllib2
import socket
import string
import time

from pymongo import MongoClient
from bson.json_util import dumps
import cherrypy

# Ensure that all operations are done in UTC
os.environ['TZ'] = 'UTC'
time.tzset()

try:
	import parsedatetime
	pdt = parsedatetime.Calendar()
except ImportError:
	pdt = None

def tconv(s):
	'''Converts time string to Epoch seconds (int).
	If parsedatetime available, we can convert various English
	expressions of time.  If not, we can only convert Epoch
	seconds as a string to Epoch seconds as int.
	'''

	try:
		return int(s)
	except ValueError:
		tm, mode = pdt.parse(s)
		ptm = list(tm)
		tmnow = list(time.gmtime())

		def _(tm):
			if mode == 1:
				tm = tm[:3] + [0, 0, 0] + tm[6:]
				# if future, subtract a year
				if time.mktime(tm) > time.mktime(tmnow):
					tm[0] -= 1
					return _(tm)
			if mode == 2:
				tm = tmnow[:3] + tm[3:]
				# if future, subtract a day
				if time.mktime(tm) > time.mktime(tmnow):
					return time.mktime(tm) - 86400
			return time.mktime(tm)

		return _(ptm)


class frob(dict):
	def __getattr__(self, key):
		return self[key]
	def __setattr__(self, key, value):
		self[key] = value


class crowhandler(object):
	def __init__(self, app):
		self.app = app

	@cherrypy.tools.accept(media='application/json')
	@cherrypy.tools.json_out()
	@cherrypy.tools.json_in()
	def POST(self, *args, **kwargs):
		print '[%.3f] request to %s' % (time.time(), self.__class__.__name__)
		return self.post(*args, **kwargs)


	def getDB(self, x):
		name = 'crow_' + x
		if hasattr(self.app.mongoclient, name):
			db = getattr(self.app.mongoclient, name)
			if hasattr(db, 'jobs'):
				return db.jobs
		return None


class starts(crowhandler):
	exposed = True

	# QDate = 1410041462
	# JobCurrentStartDate = 1410041468
	# JobStartDate = 1410041468
	# LastMatchTime = 1410041468
	# JobCurrentStartExecutingDate = 1410041470
	# CompletionDate = 1410041471
	# EnteredCurrentStatus = 1410041471
	# JobFinishedHookDone = 1410041471
	# LastJobLeaseRenewal = 1410041471

	def post(self):
		params = frob({
			'pool': 'default',
			'project': 'all',
			'user': 'all',
			'task': 'all',
			'groupby': 'ProjectName',
			'rel': 'running',
			'start': 'default',
			'end': 'default',
			'hours': 24,
			'bins': 0,
		})

		req = cherrypy.request.json

		for key in params.keys():
			if key in req:
				params[key] = type(params[key])(req[key])

		db = self.getDB(req['pool'])

		ct = int(time.time())
		if params.start == 'default' and params.end == 'default':
			interval = params.hours * 3600
			startTime = ct - interval
		elif params.start == 'default':
			interval = params.hours * 3600
			startTime = tconv(params.end) - interval
		else:
			interval = params.hours * 3600
			startTime = tconv(params.start)
		print '[] startTime=%d (%s) + %d' % (startTime, time.ctime(startTime), interval)

		if not params.bins:
			params.bins = params.hours
		binwidth = interval / params.bins

		if startTime % 3600:
			# if not an exact hour boundary, do one extra bin
			params.bins += 1
			startTime -= (startTime % 3600)

		def _or(*args):
			return { '$or': args }
		def _and(*args):
			return { '$and': args }

		# need to tune the db selection based on $rel

		andFilters = [
			#{'latest.JobStartDate': {'$lt': startTime + interval}},	# jobs that started before interval ended
		]
		if (params.project == 'all'):
			andFilters.append({'latest.ProjectName': {'$exists': True}})
		else:
			andFilters.append({'latest.ProjectName': params.project })

		if (params.user != 'all'):
			andFilters.append({'latest.User': {'$regex': params.user + '@*'} })

		if (params.task != 'all'):
			andFilters.append({'latest.ClusterId': int(params.task)})

		select = _and(
			_or(
				{'latest.CompletionDate': {'$exists': False}}, # select jobs that have not CompletionDate
				{'latest.CompletionDate': {'$gt': startTime}}, # and the ones that finished after startTime
			),
			*andFilters
		);

		rows = db.find(
			select,
			{
				'latest.QDate': 1,
				'latest.JobStatus': 1,
				'latest.ProjectName': 1,
				'latest.JobStartDate': 1,
				'latest.CompletionDate': 1,
				'latest.User': 1,
				'latest.ClusterId': 1,
				'latest.Owner': 1,
			})

		# Scale up to milliseconds
		ct *= 1000
		interval *= 1000
		binwidth *= 1000

		result = {}
		result['plot'] = []

		series = rows.distinct('latest.' + params.groupby) 
		pData = {}
		for p in series:
			pData[p] = []
			for b in range(params.bins):
				binstart = (startTime * 1000) + (b * binwidth)
				pData[p].append([binstart, 0])

		def _ilija(refstart, refend, jobstart, jobend):
			# original code, not sure what view this is for:
			if refstart > jobstart and refstart < jobend:
				return True
			return False

		def _running(refstart, refend, jobstart, jobend):
			if jobend < refstart:
				return False
			if jobstart > refend:
				return False
			return True

		def _started(refstart, refend, jobstart, jobend):
			if jobstart > refstart and jobstart < refend:
				return True
			return False

		def _finished(refstart, refend, jobstart, jobend):
			if jobend > refstart and jobend < refend:
				return True
			return False

		rel = {
			'default': (_running, 'JobStartDate'),
			'running': (_running, 'JobStartDate'),
			'started': (_started, 'JobStartDate'),
			'finished': (_finished, 'JobStartDate'),
			'ilija': (_ilija, 'JobStartDate'),
			'submitted': (_started, 'QDate'),
		}

		for r in rows:
			group = r['latest'][params.groupby]
			stime = r['latest'][rel[params.rel][1]] * 1000
			if 'CompletionDate' in r['latest']:
				etime = r['latest']['CompletionDate'] * 1000
			else:
				etime = ct
			for b in range(params.bins):
				if rel[params.rel][0](pData[group][b][0], pData[group][b][0] + binwidth, stime, etime):
					pData[group][b][1] += 1

		# not sure why yet but some of these groups come up with zero counts
		totals = {}
		for group in list(pData.keys()):
			total = sum([pData[group][x][1] for x in range(len(pData[group]))])
			if total == 0:
				del pData[group]
			else:
				totals[group] = total

		for p in series:
			if p in pData:
				ser = {}
				ser['name'] = p + ' (' + str(totals[p]) + ')'
				ser['data'] = pData[p]
				result['plot'].append(ser)

		return result


class distincts(crowhandler):
	exposed = True
	@cherrypy.tools.accept(media='application/json')
	@cherrypy.tools.json_out()
	@cherrypy.tools.json_in()

	def post(self):
		req = cherrypy.request.json

		db = self.getDB(req['pool'])

		interval = 720 * 3600
		if 'interval' in req:
			interval = req['interval'] * 3600

		ret = {}
		ret['Tasks'] = []
		ret['ProjectNames'] = []
		startTime = int(time.time())-int(interval)
		rows = db.find({'latest.CompletionDate': {'$gt': startTime}},{'latest.ProjectName': 1,'latest.User': 1,'latest.ClusterId': 1,'latest.Owner': 1})
		ret['ProjectNames'] = rows.distinct('latest.ProjectName')
		ret['Tasks'] = rows.distinct('latest.ClusterId')
		ret['Users'] = rows.distinct('latest.User')
		ret['Owners'] = rows.distinct('latest.Owner')
		for r in range(len(ret['Users'])):
			ret['Users'][r] = ret['Users'][r].split('@')[0]
		# print ret
		return ret


class crowmw(object):
	'''Crow middleware'''
	exposed = True

	def __init__(self, mongoclient):
		self.mongoclient = mongoclient
		self.distincts = distincts(self)
		self.starts = starts(self)


if __name__ == '__main__':	  
	# cherrypy.tools.CORS = cherrypy.Tool('before_finalize', CORS)
	cherrypy.config.update({'tools.log_headers.on': False})
	print cherrypy.config
	client = MongoClient('localhost', 27017)
	cherrypy.quickstart(crowmw(client), '/', '/web/crow/server/crow-server.conf')
